// ARQUIVO: ledmatrix_7219.c
// VERSÃO COMPLETA E CORRIGIDA

#include "ledmatrix_7219.h"
#include <string.h>
#include <stdbool.h>

// --- Variáveis Estáticas Internas ---
static uint8_t _din_pin;
static uint8_t _clk_pin;
static uint8_t _cs_pin;
static uint8_t _num_displays;

#define MAX_SUPPORTED_DISPLAYS 8

// --- Fonte de Caracteres ---
const uint8_t default_font[][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 32: espaço
    {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00}, // 33: !
    {0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00}, // 34: "
    {0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00, 0x00}, // 35: #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00, 0x00}, // 36: $
    {0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, 0x00}, // 37: %
    {0x36, 0x49, 0x56, 0x20, 0x50, 0x00, 0x00, 0x00}, // 38: &
    {0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00}, // 39: '
    {0x00, 0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00}, // 40: (
    {0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00}, // 41: )
    {0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00}, // 42: *
    {0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00}, // 43: +
    {0x00, 0x50, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}, // 44: ,
    {0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00}, // 45: -
    {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}, // 46: .
    {0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00}, // 47: /
    {0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00, 0x00}, // 48: 0
    {0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // 49: 1
    {0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00, 0x00}, // 50: 2
    {0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, 0x00, 0x00}, // 51: 3
    {0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00, 0x00}, // 52: 4
    {0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, 0x00}, // 53: 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00, 0x00}, // 54: 6
    {0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00, 0x00}, // 55: 7
    {0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // 56: 8
    {0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x00}, // 57: 9
    {0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // 58: :
    {0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // 59: ; (Corrigido)
    {0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00}, // 60: <
    {0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00}, // 61: =
    {0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00, 0x00}, // 62: >
    {0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00, 0x00}, // 63: ?
    {0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00, 0x00}, // 64: @
    {0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x00, 0x00}, // 65: A
    {0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // 66: B
    {0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, 0x00}, // 67: C
    {0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00}, // 68: D
    {0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, 0x00}, // 69: E
    {0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00}, // 70: F
    {0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, 0x00, 0x00}, // 71: G
    {0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00, 0x00}, // 72: H
    {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00}, // 73: I
    {0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00, 0x00}, // 74: J
    {0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00}, // 75: K
    {0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // 76: L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00, 0x00}, // 77: M
    {0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00, 0x00}, // 78: N
    {0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00, 0x00}, // 79: O
    {0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00}, // 80: P
    {0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00, 0x00}, // 81: Q
    {0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00, 0x00}, // 82: R
    {0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, 0x00}, // 83: S
    {0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00, 0x00}, // 84: T
    {0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00}, // 85: U
    {0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00, 0x00}, // 86: V
    {0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00, 0x00}, // 87: W
    {0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00, 0x00}, // 88: X
    {0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, 0x00}, // 89: Y
    {0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00}, // 90: Z
    {0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00}, // 91: [
    {0x55, 0x2A, 0x55, 0x2A, 0x55, 0x00, 0x00, 0x00}, // 92: '\' (Corrigido)
    {0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00}, // 93: ]
    {0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00}, // 94: ^
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // 95: _
    {0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00}, // 96: `
    {0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00, 0x00}, // 97: a
    {0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // 98: b
    {0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00, 0x00}, // 99: c
    {0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00, 0x00}, // 100: d
    {0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00, 0x00}, // 101: e
    {0x08, 0x7E, 0x09, 0x01, 0x02, 0x00, 0x00, 0x00}, // 102: f
    {0x0C, 0x52, 0x52, 0x52, 0x3E, 0x00, 0x00, 0x00}, // 103: g
    {0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // 104: h
    {0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, 0x00, 0x00}, // 105: i
    {0x20, 0x40, 0x44, 0x3D, 0x00, 0x00, 0x00, 0x00}, // 106: j
    {0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00}, // 107: k
    {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // 108: l
    {0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00, 0x00}, // 109: m
    {0x7C, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // 110: n
    {0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // 111: o
    {0x7C, 0x14, 0x14, 0x14, 0x08, 0x00, 0x00, 0x00}, // 112: p
    {0x08, 0x14, 0x14, 0x18, 0x7C, 0x00, 0x00, 0x00}, // 113: q
    {0x7C, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00}, // 114: r
    {0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00, 0x00}, // 115: s
    {0x04, 0x3F, 0x44, 0x40, 0x20, 0x00, 0x00, 0x00}, // 116: t
    {0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00, 0x00, 0x00}, // 117: u
    {0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00, 0x00}, // 118: v
    {0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00, 0x00}, // 119: w
    {0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00}, // 120: x
    {0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00, 0x00, 0x00}, // 121: y
    {0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00, 0x00}, // 122: z
    {0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00}, // 123: {
    {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00}, // 124: |
    {0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00}, // 125: }
    {0x02, 0x01, 0x02, 0x04, 0x02, 0x01, 0x02, 0x00}, // 126: ~
};

// --- Funções Privadas ---
static void _LedMatrix_writeData(uint8_t data) {
    for (int i = 0; i < 8; i++) {
        funDigitalWrite(_clk_pin, FUN_LOW);
        funDigitalWrite(_din_pin, (data & 0x80) ? FUN_HIGH : FUN_LOW);
        data <<= 1;
        funDigitalWrite(_clk_pin, FUN_HIGH);
    }
}

static void _LedMatrix_writeToAll(uint8_t reg, uint8_t data) {
    funDigitalWrite(_cs_pin, FUN_LOW);
    for (int i = 0; i < _num_displays; i++) {
        _LedMatrix_writeData(reg);
        _LedMatrix_writeData(data);
    }
    funDigitalWrite(_cs_pin, FUN_HIGH);
}

// --- Funções Públicas ---
void LedMatrix_init(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin, uint8_t num_displays) {
    _din_pin = din_pin; _clk_pin = clk_pin; _cs_pin = cs_pin;
    _num_displays = (num_displays > MAX_SUPPORTED_DISPLAYS) ? MAX_SUPPORTED_DISPLAYS : num_displays;
    funPinMode(_din_pin, GPIO_Speed_50MHz | GPIO_CNF_OUT_PP);
    funPinMode(_clk_pin, GPIO_Speed_50MHz | GPIO_CNF_OUT_PP);
    funPinMode(_cs_pin, GPIO_Speed_50MHz | GPIO_CNF_OUT_PP);
    funDigitalWrite(_cs_pin, FUN_HIGH);
    _LedMatrix_writeToAll(0x0F, 0x00); _LedMatrix_writeToAll(0x09, 0x00);
    _LedMatrix_writeToAll(0x0B, 0x07); _LedMatrix_writeToAll(0x0A, 15);
    _LedMatrix_writeToAll(0x0C, 0x01); LedMatrix_clearAll();
}

void LedMatrix_shutdown(int mode) { _LedMatrix_writeToAll(0x0C, mode & 0x01); }
void LedMatrix_setIntensity(int intensity) { if (intensity >= 0 && intensity <= 15) { _LedMatrix_writeToAll(0x0A, intensity); } }
void LedMatrix_clearAll(void) { for (int i = 1; i <= 8; i++) { _LedMatrix_writeToAll(i, 0x00); } }

void LedMatrix_displayImage(const uint8_t *image_buffer) {
    for (int r = 0; r < 8; r++) {
        funDigitalWrite(_cs_pin, FUN_LOW);
        for (int d = _num_displays - 1; d >= 0; d--) {
            _LedMatrix_writeData(r + 1);
            _LedMatrix_writeData(image_buffer[r * _num_displays + d]);
        }
        funDigitalWrite(_cs_pin, FUN_HIGH);
    }
}

#define FONT_CHAR_WIDTH     8
#define FONT_SPACE_WIDTH    1
#define FONT_START_CHAR     ' '
#define FONT_NUM_CHARS      95 // ✅ CORREÇÃO AQUI

// --- CORREÇÃO NA LÓGICA DE RENDERIZAÇÃO ---
void LedMatrix_displayText(const char *text) {
    int display_width_pixels = _num_displays * 8;
    uint8_t frame_buffer[8 * MAX_SUPPORTED_DISPLAYS];
    memset(frame_buffer, 0, sizeof(frame_buffer));

    int current_pixel_x = 0;
    int text_len = strlen(text);

    for (int i = 0; i < text_len; i++) {
        if (current_pixel_x >= display_width_pixels) break;

        char c = text[i];
        if (c >= FONT_START_CHAR && c < (FONT_START_CHAR + FONT_NUM_CHARS)) {
            const uint8_t *char_data = default_font[c - FONT_START_CHAR];

            for (int char_col = 0; char_col < FONT_CHAR_WIDTH; char_col++) {
                if (current_pixel_x >= display_width_pixels) break;

                // Lógica de mapeamento correta
                int display_idx_visual = current_pixel_x / 8;
                int buffer_idx_fisico = (_num_displays - 1) - display_idx_visual;
                int pixel_in_display = current_pixel_x % 8;
                
                uint8_t column_data = char_data[char_col];

                for (int row = 0; row < 8; row++) {
                    if ((column_data >> row) & 0x01) {
                        frame_buffer[row * _num_displays + buffer_idx_fisico] |= (1 << (7 - pixel_in_display));
                    }
                }
                current_pixel_x++;
            }
            current_pixel_x += FONT_SPACE_WIDTH;
        }
    }
    LedMatrix_displayImage(frame_buffer);
}

void LedMatrix_scrollText(const char *text, int speed_ms, int direction) {
    int text_len = strlen(text);
    if (text_len == 0) return;

    int text_pixel_width = 0;
    for (int i = 0; i < text_len; i++) {
        text_pixel_width += FONT_CHAR_WIDTH;
        if (i < text_len - 1) text_pixel_width += FONT_SPACE_WIDTH;
    }

    int display_width_pixels = _num_displays * 8;
    int start_pos, end_pos, step;

    if (direction == SCROLL_LEFT) {
        start_pos = display_width_pixels;
        end_pos = -text_pixel_width;
        step = -1;
    } else {
        start_pos = -text_pixel_width;
        end_pos = display_width_pixels;
        step = 1;
    }

    uint8_t frame_buffer[8 * MAX_SUPPORTED_DISPLAYS];

    for (int scroll_pos = start_pos; ; scroll_pos += step) {
        memset(frame_buffer, 0, sizeof(frame_buffer));

        for (int screen_x = 0; screen_x < display_width_pixels; screen_x++) {
            int text_x = screen_x - scroll_pos;
            if (text_x < 0 || text_x >= text_pixel_width) continue;

            int char_idx = -1, col_in_char = -1;
            int pos_tracker = 0;
            for (int i = 0; i < text_len; i++) {
                if (text_x >= pos_tracker && text_x < pos_tracker + FONT_CHAR_WIDTH) {
                    char_idx = i;
                    col_in_char = text_x - pos_tracker;
                    break;
                }
                pos_tracker += FONT_CHAR_WIDTH + FONT_SPACE_WIDTH;
            }

            if (char_idx != -1) {
                char c = text[char_idx];
                if (c >= FONT_START_CHAR && c < (FONT_START_CHAR + FONT_NUM_CHARS)) {
                    const uint8_t *char_font_data = default_font[c - FONT_START_CHAR];
                    uint8_t column_data = char_font_data[col_in_char];
                    
                    int display_idx_visual = screen_x / 8;
                    int buffer_idx_fisico = (_num_displays - 1) - display_idx_visual;
                    int pixel_in_display = screen_x % 8;

                    for (int row = 0; row < 8; row++) {
                        if ((column_data >> row) & 0x01) {
                            frame_buffer[row * _num_displays + buffer_idx_fisico] |= (1 << (7 - pixel_in_display));
                        }
                    }
                }
            }
        }
        LedMatrix_displayImage(frame_buffer);
        Delay_Ms(speed_ms);

        if ((step > 0 && scroll_pos >= end_pos) || (step < 0 && scroll_pos <= end_pos)) break;
    }
}